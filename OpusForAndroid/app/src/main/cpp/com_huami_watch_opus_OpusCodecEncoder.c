/* DO NOT EDIT THIS FILE - it is machine generated */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <jni.h>
#include "LogUtils.h"

#include <stdio.h>
#include <malloc.h>
#include "debug.h"
#include "opus.h"
#ifdef __cplusplus
extern "C" {
#endif



static OpusEncoder *enc = NULL;

static opus_int32 opus_simple_rate = 16000;
static int opus_channels = 1;
static int opus_application = OPUS_APPLICATION_AUDIO;

#define MAX_PACKET 1500
#define ERROR_OPUS_NOT_CREATE (-1001)
#define ERROR_OPUS_NOT_INIT (-1002)
#define ERROR_MAX_DATA_BYTES  (-1003)
#define ERROR_FRAME_SIZE (-1004)


static void int_to_char(opus_uint32 i, unsigned char ch[4])
{
    ch[0] = i>>24;
    ch[1] = (i>>16)&0xFF;
    ch[2] = (i>>8)&0xFF;
    ch[3] = i&0xFF;
}

static opus_uint32 char_to_int(unsigned char ch[4])
{
    return ((opus_uint32)ch[0]<<24) | ((opus_uint32)ch[1]<<16)
           | ((opus_uint32)ch[2]<< 8) |  (opus_uint32)ch[3];
}

static opus_uint32 char_to_int_(unsigned char* ch,int offset)
{
    return ((opus_uint32)ch[offset]<<24) | ((opus_uint32)ch[offset+1]<<16)
           | ((opus_uint32)ch[offset+2]<< 8) |  (opus_uint32)ch[offset+3];
}

int getFrameSize(opus_int32 sample_rate,float frame_duration){
    int frame_size = (int)(frame_duration*2*sample_rate/2000);
    return frame_size;
}

int get_frame_size_enum(int frame_size, int sampling_rate)
{
    int frame_size_enum =-1;

    if(frame_size==sampling_rate/400)
        frame_size_enum = OPUS_FRAMESIZE_2_5_MS;
    else if(frame_size==sampling_rate/200)
        frame_size_enum = OPUS_FRAMESIZE_5_MS;
    else if(frame_size==sampling_rate/100)
        frame_size_enum = OPUS_FRAMESIZE_10_MS;
    else if(frame_size==sampling_rate/50)
        frame_size_enum = OPUS_FRAMESIZE_20_MS;
    else if(frame_size==sampling_rate/25)
        frame_size_enum = OPUS_FRAMESIZE_40_MS;
    else if(frame_size==3*sampling_rate/50)
        frame_size_enum = OPUS_FRAMESIZE_60_MS;
    else if(frame_size==4*sampling_rate/50)
        frame_size_enum = OPUS_FRAMESIZE_80_MS;
    else if(frame_size==5*sampling_rate/50)
        frame_size_enum = OPUS_FRAMESIZE_100_MS;
    else if(frame_size==6*sampling_rate/50)
        frame_size_enum = OPUS_FRAMESIZE_120_MS;

    return frame_size_enum;
}


#define XLOG_PRINT(level,fmt,...) __android_log_print(level,"hmvoice",fmt,##__VA_ARGS__)
#define XLOGE(fmt,...) XLOG_PRINT(ANDROID_LOG_ERROR,fmt ,##__VA_ARGS__)


jint JNICALL Java_com_huami_watch_opus_OpusCodecEncoder_opusEncodeCreate
        (JNIEnv *env, jobject obj, jint sample_rate, jint channels, jint opus_application) {
    int err;

    opus_application = OPUS_APPLICATION_AUDIO;
    opus_simple_rate = sample_rate;
    opus_channels = channels;

    XLOGE("create encoder opus_simple_rate  %d opus_channels %d ",opus_simple_rate, opus_channels);
    enc = opus_encoder_create(opus_simple_rate, opus_channels, opus_application, &err);
    if (err != OPUS_OK) {
        fprintf(stderr, "Cannot create encoder: %s\n", opus_strerror(err));
        XLOGE("................... Cannot create encoder: %s\n", opus_strerror(err));
    }
    return err;
}


jint JNICALL Java_com_huami_watch_opus_OpusCodecEncoder_opusEncoderGetSize
        (JNIEnv * env, jobject object, jint channels){
    return opus_encoder_get_size(channels);
}


jint JNICALL Java_com_huami_watch_opus_OpusCodecEncoder_opusEncoderInit
        (JNIEnv * env, jobject object, jint sample_rate, jint channels, jint opus_application){
    if(enc == NULL){
        fprintf(stderr, "Cannot encode");
        XLOGE("Cannot encode");
        return ERROR_OPUS_NOT_CREATE;
    }

    opus_application = OPUS_APPLICATION_AUDIO;
    opus_simple_rate = sample_rate;
    opus_channels = channels;

    int error = 0;
    error =opus_encoder_init(enc,opus_simple_rate,opus_channels,opus_application);
    if (error != OPUS_OK) {
        fprintf(stderr, "Cannot init encoder: %s\n", opus_strerror(error));
        XLOGE( "Cannot init encoder: %s\n", opus_strerror(error));
    }
    return error;
}

jbyteArray JNICALL Java_com_huami_watch_opus_OpusCodecEncoder_opusIntOpusEncode
        (JNIEnv * env, jobject object, jbyteArray input_data,jfloat frame_duration,jint max_data_bytes){

    jbyte *input_byte_data  = (*env)->GetByteArrayElements(env,input_data,NULL);
    int input_byte_data_len = (*env)->GetArrayLength(env,input_data);
    unsigned char *unsigned_input_data = (unsigned char *)input_byte_data;
    if(enc == NULL){
        fprintf(stderr, "Cannot encode");
        XLOGE("Cannot encode");
        (*env)->ReleaseByteArrayElements(env,input_data,input_byte_data,0);
        return ERROR_OPUS_NOT_CREATE;
    }
    if (max_data_bytes < 0 || max_data_bytes > MAX_PACKET) {
        (*env)->ReleaseByteArrayElements(env,input_data,input_byte_data,0);
        fprintf (stderr, "max_payload_bytes must be between 0 and %d\n", MAX_PACKET);
        XLOGE("max_payload_bytes must be between 0 and %d\n", MAX_PACKET);
        return ERROR_MAX_DATA_BYTES;
    }


    int frame_size = getFrameSize(opus_simple_rate,frame_duration);
    int frame_size_enum = get_frame_size_enum(frame_size, opus_simple_rate);

    if(frame_size == -1){
        fprintf (stderr, "frame size error %d \n", frame_size);
        XLOGE("frame size error %d \n", frame_size);
        (*env)->ReleaseByteArrayElements(env,input_data,input_byte_data,0);
        return ERROR_FRAME_SIZE;
    }
//    XLOGE("duration   %d   channels %d\n", frame_size_enum,opus_channels);
    opus_encoder_ctl(enc, OPUS_SET_BITRATE(16000));
    opus_encoder_ctl(enc, OPUS_SET_EXPERT_FRAME_DURATION(OPUS_FRAMESIZE_ARG));


    opus_int32 skip = 0;
    opus_encoder_ctl(enc, OPUS_SET_BANDWIDTH(OPUS_AUTO));
    opus_encoder_ctl(enc, OPUS_SET_VBR(1));
    opus_encoder_ctl(enc, OPUS_SET_VBR_CONSTRAINT(0));
    opus_encoder_ctl(enc, OPUS_SET_COMPLEXITY(10));
    opus_encoder_ctl(enc, OPUS_SET_INBAND_FEC(0));
    opus_encoder_ctl(enc, OPUS_SET_FORCE_CHANNELS(OPUS_AUTO));
    opus_encoder_ctl(enc, OPUS_SET_DTX(0));
    opus_encoder_ctl(enc, OPUS_SET_PACKET_LOSS_PERC(0));

    opus_encoder_ctl(enc, OPUS_GET_LOOKAHEAD(&skip));
//    XLOGE("skip   %d \n", skip);
    opus_encoder_ctl(enc, OPUS_SET_LSB_DEPTH(16));
//    opus_encoder_ctl(enc, OPUS_SET_EXPERT_FRAME_DURATION(variable_duration));



    int input_count = frame_size*opus_channels* sizeof(opus_int16);
//    XLOGE("frame_size  %d   input_byte_data_len %d    input_count  %d",frame_size, input_byte_data_len,input_count);
    opus_int16* input_int_data = (opus_int16*)malloc(input_count);

//    XLOGE("---------------> input data -------------");
    char input_data_test[input_count*7+1];
    int input_data_test_len =0;

    char parser_int_data[input_count*4+1];
    int parser_int_data_len =0;

    for(int i=0;i<input_count/2;i++)
    {
        opus_int32 s;
        s=unsigned_input_data[2*i+1]<<8|unsigned_input_data[2*i];
        s=((s&0xFFFF)^0x8000)-0x8000;
        input_int_data[i]=s;

        input_data_test_len+=sprintf(input_data_test+input_data_test_len,"[%3d]%2d%2d  ",i,unsigned_input_data[2*i], unsigned_input_data[2*i + 1]);
        parser_int_data_len+=sprintf(parser_int_data+parser_int_data_len,"[%3d]%4d",i,s);
        if(i%80==0&i!=0){
            parser_int_data[parser_int_data_len+1]='\0';
            parser_int_data_len =0;
//            XLOGE("%d %s",input_count,parser_int_data);
        }
        //XLOGE("[PC %03d] %x",i, s);
    }
    input_data_test[input_data_test_len+1]='\0';
    parser_int_data[parser_int_data_len+1]='\0';
//    XLOGE("%d \n%s\n",input_count,input_data_test);
//    XLOGE("%d %s\n",input_count,parser_int_data);
//    XLOGE("---------------- input data <<<<<<<<<<<<<<\r\n");

//    XLOGE("---------------> output data -------------");
//    for(int x = 0; x <= input_count/2; x++){
//        XLOGE("[OP %03d] %04x", x, input_int_data[x]);
//    }
//    XLOGE("---------------- output data <<<<<<<<<<<<<< \r\n");

    opus_int32 r_complexity =0;
    opus_encoder_ctl(enc, OPUS_GET_COMPLEXITY(&r_complexity));
    opus_int32 r_dtx =0;
    opus_encoder_ctl(enc, OPUS_GET_DTX(&r_dtx));
    opus_int32 r_frame_duration =0;
    opus_encoder_ctl(enc, OPUS_GET_EXPERT_FRAME_DURATION(&r_frame_duration));
    opus_int32 r_force_channel =0;
    opus_encoder_ctl(enc, OPUS_GET_FORCE_CHANNELS(&r_force_channel));
    opus_int32 r_inband_fec =0;
    opus_encoder_ctl(enc, OPUS_GET_INBAND_FEC(&r_inband_fec));
    opus_int32 r_look_ahead =0;
    opus_encoder_ctl(enc, OPUS_GET_LOOKAHEAD(&r_look_ahead));
    opus_int32 r_sb_depth =0;
    opus_encoder_ctl(enc, OPUS_GET_LSB_DEPTH(&r_sb_depth));
    opus_int32 r_max_bandwidth =0;
    opus_encoder_ctl(enc, OPUS_GET_MAX_BANDWIDTH(&r_max_bandwidth));
    opus_int32 r_packet_lot_ferc =0;
    opus_encoder_ctl(enc, OPUS_GET_PACKET_LOSS_PERC(&r_packet_lot_ferc));
    opus_int32 r_fredication_disable =0;
    opus_encoder_ctl(enc, OPUS_GET_PREDICTION_DISABLED(&r_fredication_disable));
    opus_int32 r_singal =0;
    opus_encoder_ctl(enc, OPUS_GET_SIGNAL(&r_singal));
    opus_int32 r_var =0;
    opus_encoder_ctl(enc, OPUS_GET_VBR(&r_var));
    opus_int32 r_var_constraint =0;
    opus_encoder_ctl(enc, OPUS_GET_VBR_CONSTRAINT(&r_var_constraint));
    opus_int32 r_application =0;
    opus_encoder_ctl(enc, OPUS_GET_APPLICATION(&r_application));

    opus_int32 r_bitrate =0;
    opus_encoder_ctl(enc, OPUS_GET_BITRATE(&r_bitrate));
    opus_int32 r_bandwidth =0;
    opus_encoder_ctl(enc, OPUS_GET_BANDWIDTH(&r_bandwidth));

    XLOGE("r_complexity : %d  r_dtx: %d  r_frame_duration : %d  r_force_channel:%d   r_inband_fec: %d  r_look_ahead %d   r_sb_depth :%d   r_max_bandwidth : %d   r_packet_lot_ferc:%d  r_fredication_disable: %d   r_singal: %d   r_var: %d    r_var_constraint: %d   r_application: %d   r_bitrate  :%d  r_bandwidth : %d"
            , r_complexity,r_dtx,r_frame_duration,r_force_channel,r_inband_fec,r_look_ahead,r_sb_depth,r_max_bandwidth,r_packet_lot_ferc,r_fredication_disable,r_singal,r_var,r_var_constraint,r_application,r_bitrate,r_bandwidth);




    jbyteArray out = NULL;

    unsigned char *out_data = (unsigned char *) malloc(max_data_bytes * sizeof(unsigned char));
    int result =  opus_encode(enc,input_int_data,frame_size,out_data,max_data_bytes);

    char encode_result [result*8+1];
    int offset = 0;
    for(int m = 0;m< result;m++){
        //fprintf(stderr,"PC %02X   %d   ",data[toggle][m]);
        offset += sprintf(encode_result+offset,"%02X  ",out_data[m]);
    }
    encode_result[offset+1]='\0';
    XLOGE("\n>>>>>>>>>>>>>>>>>>>>>>>>>output===================\n");
    XLOGE("%d \n%s\n",result,encode_result);
    XLOGE("\n================output<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n");

//    unsigned char content [result+1];
//    content[result] ='\0';

//    for(int m =0;m<result;m++){
////        content[m]= out_data[m];
//        XLOGE(" %d",out_data[m] );
//    }

    if(result>0){
        int start_index = 0;
        char has_header = 0;
        out = (*env)->NewByteArray(env,result);
        if(has_header){
            unsigned char int_field[4];
            int_to_char(result,int_field);
            (*env)->SetByteArrayRegion(env,out, start_index, 4, int_field);
            start_index+=4;
            unsigned char enc_final_range[4];
            opus_uint32 final_range =0;
            opus_encoder_ctl(enc, OPUS_GET_FINAL_RANGE(&final_range));
            int_to_char(final_range,enc_final_range);
            (*env)->SetByteArrayRegion(env,out, start_index, 4, enc_final_range);
            start_index+=4;
        }

        (*env)->SetByteArrayRegion(env,out, start_index, result, out_data);
        (*env)->ReleaseByteArrayElements(env,input_data,input_byte_data,0);
        free(out_data);
        return out;
    }else{
        (*env)->ReleaseByteArrayElements(env,input_data,input_byte_data,0);
        free(out_data);
        return NULL;
    }
}



void JNICALL  Java_com_huami_watch_opus_OpusCodecEncoder_opusEncoderDestroy
        (JNIEnv * env, jobject object){
    if(enc != NULL){
        opus_encoder_destroy(enc);
        enc = NULL;
    }
    return;
}


jint JNICALL  Java_com_huami_watch_opus_OpusCodecEncoder_opusEncodeCtl
        (JNIEnv *env, jobject object, jint request) {
    if(enc == NULL){
        return -1;
    }
    return opus_encoder_ctl(enc, request);
}

#ifdef __cplusplus
}
#endif
